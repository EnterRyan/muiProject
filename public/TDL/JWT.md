# JWT(Json Web Token)을 알아보자.

### 우리가 사이트를 이용할때 로그인을 하는 이유가 무엇인가!

- 우리가 클라이언트에서 서버로 요청을 보낼때는 항상 누가 요청을 보내는지 확인이 필요하다.
- 게시판을 예로 들면 글쓰기, 글삭제, 글 수정 과 같이 인가가 허용된 사용자만이 서비스를 접근할 수있어야 하기 때문이다.
- 하여 만약 로그인과 같은 기능이 없다면 우린 서비스를 보낼때마다 사용자에게 정보를 전달받아서 서버에 요청을 해야하기에 너무 불편하다.
- 하여 클라이언트는 서버에 요청을 보낼때 매번 로그인을 하는 것이 아닌 서버에 정보를 보내어 지금부터 서비스를 이용하는 것은 나야! 라고 증명(인증) 할 수있는 무언가가 필요하고, 그 첫 발걸음이 로그인이다.
  <br>

### 로그인 후 이루어지는 인증 방식들.

> - 우선 인증과 인가가 뭘 뜻하는 것인지를 알아야한다.

#### 인증이란

> - 접속자가 나를 증명하는 방법.
> - 추가로 서비스를 이용하는 인증된 사용자를 추적 할 수 있다.

#### 인가란

> - 인증된 사용자가 접근할 수 있는 리소스.
> - 게시판의 경우 내가 쓴 글만 수정 삭제 할 수 있고, 모든 사용자는 글을 열람, 추가 할 수있다.

#### 인증의 방식에는 3가지 방식이 있다.

1. Cookie 방식
   > - 사용자의 인증 정보를 쿠키에 등록하여 HTTP 요청을 보낼때 쿠키의 값을 보내는 형태.
   > - 만료기간 및 정보를 클라이언트에서 관리한다.
   > - 쿠키는 탈취 및 조작이 너무 간단해서 더이상 사용 하지않음.
2. Session 방식
   > - 사용자의 입력정보를 특정 규칙에 의하여 암호화(SessionID) 하여 서버의 "세션 스토리지"에 저장 후 클라이언트에게도 전달.
   > - 브라우저는 전달 받은 SessionID를 쿠키에 저장하고 HTTP 요청을 보낼때 해더에 해당 값을 전달한다.
   > - 서버는 전달받은 SessionId 와 "세션 스토리지"에 있는 값을 비교하여 사용자의 인증을 완료한다.
   > - 서버에서 "세션 스토리지"라는 저장공간이 있다보니 대용량 트레픽이 발생하면 리소스 소모도 크고 확장성에도 좋지 못했다.
3. Token 방식
   > - 클라이언트에서 로그인이 성공하면 사용자 정보(민감한 정보 제외)와 기타 여러가지를 담은 Header와 Payload 그리고
   >   두 데이터를 해싱한 값을 클라이언트에게 응답 해더에 담아 보내는 형식.
   > - 즉 사용자 인증 정보를 서버에서 관리하지 않고, 사용자 정보를 토큰에 담아서 클라이언트에 전달하는 인증 방식입니다.
   > - 클라이언트는 전달받은 토큰을 저장하고 싶은 곳(웹 스토리지 또는 쿠키)에 저장하여 HTTP요청을 보낼때 마다 헤더에 전달.
   > - Cookie 처럼 조작이 가능하지만 해싱을 통한 값을 포함하기에 비밀키가 유출되지 않은 이상 서버에서 튕겨내기 가능.
   > - 그렇지만 완전히 Session방식을 대체할 개꿀 방식은 또 아닌게 보안적인 측면으로 장/단점이 있음.

#### 그럼 토큰 방식의 장점은 무엇일까?

- 우리의 큰 적 CORS에 영향을 받지 않는다.
  > - 브라우저가 CORS를 체킹하는 방법은 HTTP 헤더를 참조하는 것인데, Session방식에서 사용하는 HTTP 요청은 헤더에 출처에 대한 정보를 가지고 있다. (Access-control-Allow-Origin)
  > - 이 출처에 대한 헤더 정보가 브라우저의 발생지와 다르면 CORS 예외를 발생시킨다.
  > - 토큰 방식의 경우 헤더에 Access-control-Expose-Header 의 형태가 존재하는데......(이게뭔지는 좀더..)
- 세션 방식과 다르게 서버에 별도의 저장공간(세션스토리지)를 두지 않아도 된다.

#### 킹치만 토큰 방식도 단점은 있다.

- 가장 큰 문제점으로 토큰은 웹 스토리지(로컬 스토리지)와 쿠키에 저장되는데 이는 탈취가 가능하다.
  > - 그래서 만료시간과 같은 개발자가 지정한 설정이 필요하다.
- HTTP CRLF인젝션 취약점을 가지고 있다. (Payload에 임의 값을 지정하여 권한 상승 공격.)
  > - CRLF 인젝션은 HTTP 해더에 줄바꿈 코드를 삽입하여 헤더필드에 임의의 응답 헤더나 바디를 추가하여 공격 코드를 보내는 것이다.
  > - A 사용자가 해커 B사용자가 만든 피싱 사이트에서 로그인을 시도시 로그인정보 + 페이로드에 소스를 추가하여 원 서버에 토큰 발급을 요청 후 나쁜작업을 함.
- 키 유출을 방지하기 위한 Saltting과 Key Stratching을 사용하려면 결국 서버에 salt 저장공간을 만들어야 함.

#### 그러면 어쩌라구요!

- JWT를 사용하려면 우선 API에 접근할때 사용되는 엑세스 토큰의 경우 유효기간을 짧게 두고(탈취방지)
  리프레쉬 토큰을 이용해야한다. (사실 토큰은 탈취당한 사람 잘못임ㅋ)
- CRLF 인젝션을 방어하기 위해서는 서버/클라이언트 각각 보안 작업을 해둬야한다.

  > 서버
  >
  > - JWT 생성시에 헤더와 페이로드 내용에 존재하는 CRLF 문자열을 제거해야 합니다.
  > - JWT를 검증할 때, 헤더와 페이로드 내용에 존재하는 CRLF 문자열을 제거한 후, 검증을 진행해야합니다.

  > 클라이언트
  >
  > - JWT를 HTTP 요청 헤더에 포함시키기 전에, JWT 내용 중에 CRLF 문자열이 존재하는지를 확인해야합니다.
  > - JWT 내용 중에 CRLF 문자열이 존재한다면, 해당 JWT를 사용하지 말고 새로운 JWT를 요청해야합니다.
  > - JWT를 URL 파라미터에 포함시키는 경우, URL 인코딩을 해야합니다.

#### 이제 진짜! JWT를 알아보자. 로그인 프로세스를 간략하게 알아보자.

1. 사용자 로그인 시도.
2. 서버에서 계정 유효성 검사 및 토큰 발급(Access Token).
3. 클라이언트에서 토큰을 쿠키에 저장.
4. API 요청 시, HTTP 헤더에 토큰 전달.
5. 응답 전 토큰 검사 실시, 문제 없을 경우 계속 진행.(만료, 해쉬 검증)

#### 자세하게 알아보자 Part 1 JWT의 구조

#### 자세하게 알아보자 Part 2 JWT의 구조(생성,전달, 검증.)

#### 자세하게 알아보자 Part 3 JWT의 보안 기능.(salt, escape)
